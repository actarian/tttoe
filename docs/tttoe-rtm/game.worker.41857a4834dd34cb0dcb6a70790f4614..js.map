{"version":3,"sources":["webpack:///./src/components/game/game.ai.ts","webpack:///./src/components/game/game.worker.ts"],"names":["MAX_SCORE","Number","POSITIVE_INFINITY","canMove","board","i","getScore","b","player","opponent","row","col","minimax","depth","isMax","stats","best","score","GameAi","win","matches","loss","Math","max","min","findBestMove","moves","push","move","reduce","p","c","bestMoves","filter","x","length","floor","random","self","addEventListener","event","data","bestMove","postMessage"],"mappings":"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","file":"game.worker.xxxxxxxxxxxxxxxxxxxx.worker.js","sourcesContent":["import { SquareValue } from \"../types\";\n\nconst MAX_SCORE = Number.POSITIVE_INFINITY;\n\nexport class GameAi {\n\n  static canMove(board: SquareValue[]): boolean {\n    for (let i = 0; i < 9; i++) {\n      if (board[i] === null) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  static getScore(b: SquareValue[], player: SquareValue, opponent: SquareValue): number {\n    // Checking for Rows for X or O victory.\n    for (let row = 0; row < 9; row+=3) {\n      if (b[row] == b[row + 1] && b[row + 1] == b[row + 2]) {\n        if (b[row] === player) {\n          return +10;\n        } else if (b[row] === opponent) {\n          return -10;\n        }\n      }\n    }\n    // Checking for Columns for X or O victory.\n    for (let col = 0; col < 3; col++) {\n      if (b[col] === b[col + 3] && b[col + 3] === b[col + 6]) {\n        if (b[col] === player) {\n          return +10;\n        } else if (b[col] === opponent) {\n          return -10;\n        }\n      }\n    }\n    // Checking for Diagonals for X or O victory.\n    if (b[0] === b[4] && b[4] === b[8]) {\n      if (b[0] == player) {\n        return +10;\n      } else if (b[0] == opponent) {\n        return -10;\n      }\n    }\n    if (b[2] === b[4] && b[4] === b[6]) {\n      if (b[2] == player) {\n        return +10;\n      } else if (b[2] == opponent) {\n        return -10;\n      }\n    }\n    // Else if none of them have won then return 0\n    return 0;\n  }\n\n  // This is the minimax function. It considers all\n  // the possible ways the game can go and returns\n  // the value of the board\n  static minimax(board: SquareValue[], depth: number, isMax: boolean, player: SquareValue, opponent: SquareValue, stats: { matches: number, win: number, loss: number }): number {\n    const score: number = GameAi.getScore(board, player, opponent);\n    /*\n    console.log(board.map((x,i) => {\n      return (x || '_') + ((i + 1) % 3 === 0 ? '\\n' : '');\n    }).join(' '), score);\n    */\n    // If Maximizer has won the game\n    // return his/her evaluated score\n    if (score == 10) {\n      stats.win ++;\n      stats.matches ++;\n      return score;\n    }\n    // If Minimizer has won the game\n    // return his/her evaluated score\n    if (score == -10) {\n      stats.loss ++;\n      stats.matches ++;\n      return score;\n    }\n    // If there are no more moves and\n    // no winner then it is a tie\n    if (!GameAi.canMove(board)) {\n      stats.matches ++;\n      return 0;\n    }\n    // If this maximizer's move\n    let best: number;\n    if (isMax) {\n      best = -MAX_SCORE;\n      // Traverse all cells\n      for (let i = 0; i < 9; i++) {\n        const b = board;\n        // const b = board.slice();\n        // Check if cell is empty\n        if (b[i] === null) {\n          // Make the move\n          b[i] = player;\n          // Call minimax recursively and choose\n          // the maximum value\n          best = Math.max(best, GameAi.minimax(b, depth + 1, !isMax, player, opponent, stats));\n          // Undo the move\n          b[i] = null;\n        }\n      }\n    } else {\n      // If this minimizer's move\n      best = MAX_SCORE;\n      // Traverse all cells\n      for (let i = 0; i < 9; i++) {\n        const b = board;\n        // const b = board.slice();\n        // Check if cell is empty\n        if (b[i] === null) {\n          // Make the move\n          b[i] = opponent;\n          // Call minimax recursively and choose\n          // the minimum value\n          best = Math.min(best, GameAi.minimax(b, depth + 1, !isMax, player, opponent, stats));\n          // Undo the move\n          b[i] = null;\n        }\n      }\n    }\n    return best;\n  }\n\n  // This will return the best possible\n  // move for the player\n  static findBestMove(board: SquareValue[], player:SquareValue, opponent: SquareValue): number {\n    const moves: { score: number, move: number }[] = [];\n    // Traverse all cells, evaluate minimax function\n    // for all empty cells. And return the cell\n    // with optimal value.\n    const stats = { matches: 0, win: 0, loss: 0 };\n    for (let i = 0; i < 9; i++) {\n      const b = board;\n      // const b = board.slice();\n      // Check if cell is empty\n      if (!b[i]) {\n        // Make the move\n        b[i] = player;\n        // compute evaluation function for this\n        // move.\n        const score: number = GameAi.minimax(b, 0, false, player, opponent, stats);\n        moves.push({ score, move: i });\n        // Undo the move\n        b[i] = null;\n      }\n    }\n    const best = moves.reduce((p, c) => {\n      return c.score > p ? c.score : p;\n    }, -MAX_SCORE);\n    const bestMoves = moves.filter(x => x.score === best);\n    if (bestMoves.length) {\n      const i = Math.floor(bestMoves.length * Math.random());\n      return bestMoves[i].move;\n    } else {\n      return -1;\n    }\n  }\n\n}\n","// worker\n\nconst ctx: Worker = self as any;\n\nimport { GameAi } from './game.ai';\n\n// console.log('game.worker.ts', ctx);\n\nctx.addEventListener('message', (event) => {\n  // console.log('game.worker.ts', event);\n  if (event && event.data) { // && event.data.type === 'findBestMove'\n    const data = event.data;\n    const bestMove = GameAi.findBestMove(data.board, data.player, data.opponent);\n    postMessage({ bestMove });\n  }\n});\n"],"sourceRoot":""}