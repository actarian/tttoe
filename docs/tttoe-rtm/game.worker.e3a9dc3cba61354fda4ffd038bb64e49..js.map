{"version":3,"sources":["webpack:///./src/components/game/game.ai.ts","webpack:///./src/components/game/game.worker.ts"],"names":["MAX_SCORE","Number","POSITIVE_INFINITY","canMove","board","i","getScore","b","player","opponent","row","col","minimax","depth","isMax","stats","best","score","GameAi","win","matches","loss","Math","max","min","findBestMove","moves","push","move","reduce","p","c","bestMoves","filter","x","length","floor","random","self","addEventListener","event","data","bestMove","postMessage"],"mappings":"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","file":"game.worker.xxxxxxxxxxxxxxxxxxxx.worker.js","sourcesContent":["import { SquareValue } from \"../types\";\r\n\r\nconst MAX_SCORE = Number.POSITIVE_INFINITY;\r\n\r\nexport class GameAi {\r\n\r\n  static canMove(board: SquareValue[]): boolean {\r\n    for (let i = 0; i < 9; i++) {\r\n      if (board[i] === null) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  static getScore(b: SquareValue[], player: SquareValue, opponent: SquareValue): number {\r\n    // Checking for Rows for X or O victory.\r\n    for (let row = 0; row < 9; row+=3) {\r\n      if (b[row] == b[row + 1] && b[row + 1] == b[row + 2]) {\r\n        if (b[row] === player) {\r\n          return +10;\r\n        } else if (b[row] === opponent) {\r\n          return -10;\r\n        }\r\n      }\r\n    }\r\n    // Checking for Columns for X or O victory.\r\n    for (let col = 0; col < 3; col++) {\r\n      if (b[col] === b[col + 3] && b[col + 3] === b[col + 6]) {\r\n        if (b[col] === player) {\r\n          return +10;\r\n        } else if (b[col] === opponent) {\r\n          return -10;\r\n        }\r\n      }\r\n    }\r\n    // Checking for Diagonals for X or O victory.\r\n    if (b[0] === b[4] && b[4] === b[8]) {\r\n      if (b[0] == player) {\r\n        return +10;\r\n      } else if (b[0] == opponent) {\r\n        return -10;\r\n      }\r\n    }\r\n    if (b[2] === b[4] && b[4] === b[6]) {\r\n      if (b[2] == player) {\r\n        return +10;\r\n      } else if (b[2] == opponent) {\r\n        return -10;\r\n      }\r\n    }\r\n    // Else if none of them have won then return 0\r\n    return 0;\r\n  }\r\n\r\n  // This is the minimax function. It considers all\r\n  // the possible ways the game can go and returns\r\n  // the value of the board\r\n  static minimax(board: SquareValue[], depth: number, isMax: boolean, player: SquareValue, opponent: SquareValue, stats: { matches: number, win: number, loss: number }): number {\r\n    const score: number = GameAi.getScore(board, player, opponent);\r\n    /*\r\n    console.log(board.map((x,i) => {\r\n      return (x || '_') + ((i + 1) % 3 === 0 ? '\\n' : '');\r\n    }).join(' '), score);\r\n    */\r\n    // If Maximizer has won the game\r\n    // return his/her evaluated score\r\n    if (score == 10) {\r\n      stats.win ++;\r\n      stats.matches ++;\r\n      return score;\r\n    }\r\n    // If Minimizer has won the game\r\n    // return his/her evaluated score\r\n    if (score == -10) {\r\n      stats.loss ++;\r\n      stats.matches ++;\r\n      return score;\r\n    }\r\n    // If there are no more moves and\r\n    // no winner then it is a tie\r\n    if (!GameAi.canMove(board)) {\r\n      stats.matches ++;\r\n      return 0;\r\n    }\r\n    // If this maximizer's move\r\n    let best: number;\r\n    if (isMax) {\r\n      best = -MAX_SCORE;\r\n      // Traverse all cells\r\n      for (let i = 0; i < 9; i++) {\r\n        const b = board;\r\n        // const b = board.slice();\r\n        // Check if cell is empty\r\n        if (b[i] === null) {\r\n          // Make the move\r\n          b[i] = player;\r\n          // Call minimax recursively and choose\r\n          // the maximum value\r\n          best = Math.max(best, GameAi.minimax(b, depth + 1, !isMax, player, opponent, stats));\r\n          // Undo the move\r\n          b[i] = null;\r\n        }\r\n      }\r\n    } else {\r\n      // If this minimizer's move\r\n      best = MAX_SCORE;\r\n      // Traverse all cells\r\n      for (let i = 0; i < 9; i++) {\r\n        const b = board;\r\n        // const b = board.slice();\r\n        // Check if cell is empty\r\n        if (b[i] === null) {\r\n          // Make the move\r\n          b[i] = opponent;\r\n          // Call minimax recursively and choose\r\n          // the minimum value\r\n          best = Math.min(best, GameAi.minimax(b, depth + 1, !isMax, player, opponent, stats));\r\n          // Undo the move\r\n          b[i] = null;\r\n        }\r\n      }\r\n    }\r\n    return best;\r\n  }\r\n\r\n  // This will return the best possible\r\n  // move for the player\r\n  static findBestMove(board: SquareValue[], player:SquareValue, opponent: SquareValue): number {\r\n    const moves: { score: number, move: number }[] = [];\r\n    // Traverse all cells, evaluate minimax function\r\n    // for all empty cells. And return the cell\r\n    // with optimal value.\r\n    const stats = { matches: 0, win: 0, loss: 0 };\r\n    for (let i = 0; i < 9; i++) {\r\n      const b = board;\r\n      // const b = board.slice();\r\n      // Check if cell is empty\r\n      if (!b[i]) {\r\n        // Make the move\r\n        b[i] = player;\r\n        // compute evaluation function for this\r\n        // move.\r\n        const score: number = GameAi.minimax(b, 0, false, player, opponent, stats);\r\n        moves.push({ score, move: i });\r\n        // Undo the move\r\n        b[i] = null;\r\n      }\r\n    }\r\n    const best = moves.reduce((p, c) => {\r\n      return c.score > p ? c.score : p;\r\n    }, -MAX_SCORE);\r\n    const bestMoves = moves.filter(x => x.score === best);\r\n    if (bestMoves.length) {\r\n      const i = Math.floor(bestMoves.length * Math.random());\r\n      return bestMoves[i].move;\r\n    } else {\r\n      return -1;\r\n    }\r\n  }\r\n\r\n}\r\n","// worker\r\n\r\nconst ctx: Worker = self as any;\r\n\r\nimport { GameAi } from './game.ai';\r\n\r\n// console.log('game.worker.ts', ctx);\r\n\r\nctx.addEventListener('message', (event) => {\r\n  // console.log('game.worker.ts', event);\r\n  if (event && event.data) { // && event.data.type === 'findBestMove'\r\n    const data = event.data;\r\n    const bestMove = GameAi.findBestMove(data.board, data.player, data.opponent);\r\n    postMessage({ bestMove });\r\n  }\r\n});\r\n"],"sourceRoot":""}